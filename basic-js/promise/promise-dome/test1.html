<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

    const PENDING = 'PENDING';

    const FULFILLED = 'FULFILLED';

    const REJECTED = 'REJECTED';

    class APromise {
        constructor(executor) {

            this.status = PENDING;
            // 存放成功状态的值
            this.value = undefined;
            // 存放失败状态的值
            this.reason = undefined;
            // 处理异步
            this.onResolvedCallbacks = [];  // 新增  一个数组存放成功处理
            this.onRejectedCallbacks = [];  // 新增  一个数组存放失败处理

            // 调用此方法就是成功
            let resolve = (value) => {
                // 状态为 PENDING 时 才可以更新状态
                // 使用 macro-task 机制(setTimeout),确保onFulfilled 异步执行，且在then 方法被调用的那一轮事件循环之后的新执行栈中执行
                // 加上这个，主要是为了处理executor 函数中代码为非异步的情况
                setTimeout(() => {
                    if(this.status === PENDING) {
                        this.status = FULFILLED
                        this.value = value
                        this.onResolvedCallbacks.forEach((fn) => {   // 新增 触发时遍历所有
                            this.value = fn(this.value)
                        })
                    }
                })
            }
            // 调用此方法就是失败
            let reject = (reason) => {
                setTimeout(() => {
                    if(this.status === PENDING) {
                        this.status = REJECTED;
                        this.reason = reason;
                        this.onRejectedCallbacks.forEach((fn) => {    // 新增 触发时遍历所有
                            this.reason = fn(this.reason)
                        })
                    }
                })
            }
            
            // 处理异常情况
            try {
                // 立即执行，将resolve 和 reject 函数，传给使用者
                executor(resolve, reject)
                // 其实就是在这里执行的
            } catch (error) {
                reject(error)  // 出错了 reason 就是错误
            }
        }

        // 包含一个 then 方法， 并接收两个参数函数 onFulfilled、onRejected
        then(onFulfilled, onRejected) {
            // 改造就变成如下：
            typeof onFulfilled === 'function' && this.onResolvedCallbacks.push(onFulfilled);
            typeof onRejected === 'function' && this.onRejectedCallbacks.push(onRejected);
            
            return this;
        }
    }

    const p = new APromise((resolve, reject) => {
        setTimeout(() => {
            resolve(2);
        }, 2000)
    })
        .then('哈哈')
        .then(res => {
            console.log(res)
        })
    </script>
</body>
</html>