<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 1.1 题目一
    // const promise1 = new Promise((resolve, reject) => {
    //   console.log('promise1')
    // })

    // console.log('1', promise1)

    // 1.2 题目二
    // const promise = new Promise((resolve, reject) => {
    //   console.log('1');
    //   resolve('success');
    //   console.log('2')
    // })

    // promise.then(() => {
    //   console.log('3')
    // })

    // console.log('4')

    // 执行结果 1 2 4 3

    // 1.3 题目三

    // const promise = new Promise((resolve, reject) => {
    //   console.log('1')
    //   console.log('2')
    // })

    // promise.then(() => {
    //   console.log('3')
    // })

    // console.log('4')

    // 执行结果  1 2 4

    // 和题目二相似，只不过在 promise 中 并没有 resolve 或者 reject   ****** 没有所以没有被执行
    // 因此 promise.then 并不会执行，它只有在被改变了状态之后才会执行

    // 1.4 题目四

    // const promise1 = new Promise((resolve, reject) => {
    //   console.log('promise1')
    //   resolve('resolve1')
    // })
    
    // const promise2 = promise1.then((res) => {
    //   console.log(res)
    // })

    // console.log('1', promise1)
    // console.log('2', promise2)

    // 执行结果  'promise1'
    // '1' Promise{<fulfilled>: "resolve1"}
    // '2' Promise{<pending>}
    // 'resolve1'

    // 1.5 题目五
    
    // const fn = () => (new Promise((resolve, reject) => {
    //   console.log(1);
    //   resolve('success')
    // }))

    // fn().then(res => {
    //   console.log(res)
    // })

    // console.log('start')
    
    // 执行结果
    // 1
    // 'start'
    // 'success'

    // 1.6 题目六
    // const fn = () => new Promise((resolve, reject) => {
    //   console.log(1)
    //   resolve('success')
    // })

    // console.log('start')

    // fn().then((res) => {
    //   console.log(res)
    // })

    // 执行结果
    // 'start'
    //  1
    // 'success'

    // Promise 结合 setTimeout
    // 2.1 题目一

    // console.log('start')
    
    // setTimeout(() => {
    //   console.log('time')
    // }, 0)

    // Promise.resolve().then((res) => {
    //   console.log('resolve')
    // })

    // console.log('end')

    // 过程分析
    // 刚开始 整个脚本作为一个宏任务来执行，对于同步代码直接压入执行栈进行执行，因此先打印出 start 和 end。
    // setTimeout 作为一个宏任务被放入宏任务队列 （下一个） ******
    // Promise.then 作为一个微任务被放入微任务队列
    // 本次宏任务执行完，检查微任务，发现 Promise.then，执行它
    // 接下来进入下一个宏任务，发现 setTimeout， 执行

    // 执行结果
    // 'start'
    // 'end'
    // 'resolve'
    // 'time'

    // 2.2 题目二
    // const promise = new Promise((resolve, reject) => {
    //   console.log(1)
    //   setTimeout(() => {
    //     console.log('timeStart')
    //     resolve('success')
    //     console.log('timeEnd')
    //   }, 0)
    //   console.log(2)
    // })

    // promise.then((res) => {
    //   console.log(res)
    // })

    // console.log(4)
    
    // 执行结果
    // 1
    // 2
    // 4
    // 'timerStart'
    // 'timeEnd'
    // 'success'

    // 2.3 题目三
    
    // 第一道
    // setTimeout(() => {
    //   console.log('timer1');
    //   setTimeout(() => {
    //     console.log('timer3')
    //   }, 0)
    // }, 0)
    // setTimeout(() => {
    //   console.log('timer2')
    // }, 0)
    // console.log('start')

    // 执行结果
    // 'start'
    // 'timer1'
    // 'timer2'
    // 'timer3'

    // 第二道
    // setTimeout(() => {
    //   console.log('timer1');
    //   Promise.resolve().then(() => {
    //     console.log('promise')
    //   })
    // }, 0)
    // setTimeout(() => {
    //   console.log('timer2')
    // }, 0)
    // console.log('start')

    // 执行结果
    // 'start'
    // 'timer1'
    // 'promise'
    //  timer2

    // 2.4 题目四
    // Promise.resolve().then(() => {
    //   console.log('promise1');
    //   const timer2 = setTimeout(() => {
    //     console.log('timer2')
    //   }, 0)
    // });
    // const timer1 = setTimeout(() => {
    //   console.log('timer1')
    //   Promise.resolve().then(() => {
    //     console.log('promise2')
    //   })
    // }, 0)
    // console.log('start');

    // 执行结果
    // 'start'
    // 'promise1'
    // 'timer1'
    // 'promise2'
    // 'timer2'

    // 2.5 题目五    *******
    
    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve('success')
    //   }, 1000)
    // })

    // const promise2 = promise1.then(() => {
    //   throw new Error('error!!!')
    // })

    // console.log('promise1', promise1)
    // console.log('promise2', promise2)

    // setTimeout(() => {
    //   console.log('promise1', promise1)
    //   console.log('promise2', promise2)
    // }, 2000)

    // 我觉得 抛出 error 之后不会再继续往下执行了 // 错误的想法，因为事实是还会往下执行
    // 我的答案
    // 'promise1' promise1{<pending>}
    // 'promise2' promise2{<pending>}
    // 'error!!!!'

    // 正确的答案
    // 'promise1' Promise{<pending>}
    // 'promise2' Promise{<pending>}
    // Uncaugth (in promise) Error: error!!!!   // 解释：抛出了一个错误，且将promise2的状态设置为了 rejected
    // 'promise1' Promise{<fulfilled>: 'success'}
    // 'promise2' Promise{<rejected>: Error: error!!!}

    // 2.6 题目六

    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("success");
    //     console.log("timer1");
    //   }, 1000);
    //   console.log("promise1里的内容");
    // });
    // const promise2 = promise1.then(() => {
    //   throw new Error("error!!!");
    // });
      // console.log("promise1", promise1);
      // console.log("promise2", promise2);
    // setTimeout(() => {
    //   console.log("timer2");
    //   console.log("promise1", promise1);
    //   console.log("promise2", promise2);
    // }, 2000);

    // 执行结果
    // 'promise1里的内容'
    // 'promise1' Promise{<pending>}
    // 'promise2' Promise{<pending>}
    // 'timer1'
    // Uncaught (in promise) Error: error!!!
    // 'timer2'
    // 'promise1' Promise{<fulfilled>: 'success'}
    // 'promise2' Promise{<rejected>: Error: error!!!}

    // Promise 中的 then、catch、finally
    // .then 或者 .catch 的参数期望是函数，传入非函数则会发生值透传   ****  
    // .finally 方法 也是返回一个 Promise，他在 Promise 结束的时候，无论结果为 resolved 还是 rejected 都会执行里面的回调函数    ****

    // 3.1 题目一

    // const promise = new Promise((resolve, reject) => {
    //   resolve('success1')
    //   reject('error')
    //   resolve('success2')
    // })

    // promise.then((res) => {
    //   console.log('then：', res)
    // }).catch((res) => {
    //   console.log('then：', res)
    // })
    // 我的答案  // 错误的想法： 以为多个 resovle, reject 混合后会依次执行
    // 'then: ' 'success1'
    // 'catch: ' 'error'
    // 'then: ' 'success2'

    // 解释：
    // 构造函数中 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用。***Promise的状态一经改变就不能再改变***
    // 执行结果
    // 'then：success1'

    // 3.2  题目二
    // 我的答案    // 错误的想法， 以为 resovle 对应的就是 then，reject 对应的是 catch，并且只会执行一次，其实后面还有点的，属于链式执行  ***
    // 'catch: "error"'

    // const promise = new Promise((resolve, reject) => {
    //   reject('error')
    //   resolve('success')
    // })

    // promise.then((res) => {
    //   console.log('then1：', res)
    // }).then((res) => {
    //   console.log('then2：', res)
    // }).catch((err) => {
    //   console.log('catch：', err)
    // }).then((res) => {
    //   console.log('then3：', res)
    // })

    
    // 执行结果
    // 'catch：' 'error'
    // 'then3：' undefined
    
    // 解释：
    // 至于 then3 也会被执行，那是因为catch() 也会返回一个 Promise，且由于这个Promise 没有返回值，所以打印出来的是 undefined

    // 3.3  题目3
    // 我的答案  错误的想法 // 以为 catch 不执行，那么后面的then 也不会执行   ****
    // 1

    Promise.resolve(1).then((res) => {
      console.log(res)
      return 2
    }).catch((err) => {
      return 3
    }).then((res) => {
      console.log(res)
    })

    // 执行结果
    // 1
    // 2

    // 3.4 题目4
    Promise.reject(1)
    .then(res => {
      console.log(res);
      return 2;
    })
    .catch(err => {
      console.log(err);
      return 3
    })
    .then(res => {
      console.log(res);
    });

    // 执行结果
    // 1
    // 3

    // 3.5 题目5
    // 执行结果
 
  </script>
</body>
</html>

