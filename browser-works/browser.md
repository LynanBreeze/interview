

笔记

HTTP 请求分为三个部分： TCP 三次握手、http 请求响应信息、关闭 TCP 连接

相关面试题

## 输入url到页面呈现发生了什么

+ DNS 解析：将域名解析成IP地址
+ TCP 连接：TCP 三次握手
+ 发送 HTTP 请求
+ 服务器处理请求并返回 HTTP 报文
+ 浏览器解析渲染页面
+ 断开连接：TCP 四次握手

[参考文章](https://zhuanlan.zhihu.com/p/57895541)
[参考文章](https://github.com/impeiran/Blog/issues/3)

## 浏览器的渲染过程

1、根据HTML 标记并构建DOM树
2、根据CSS构建CSS树 (CSSOM)
3、将两颗树合并成一棵渲染树 (render tree)
4、layout 布局 (文档流，盒模型，计算大小或位置等)
5、paint 绘制 (边框颜色，背景颜色，阴影等绘制)
6、componse 合成 (根据层叠关系展示画面)

[参考文章](https://juejin.im/post/6844904147779584007)

## 浏览器的回流与从重绘

### 回流(Reflow)

回流必将引起重绘，重绘不一定会引起回流。

当Render Tree 中部分或全部元素的尺寸，结构，或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。
 
### 重绘(Repaint)

当页面中元素样式的改变并不影响它在文档流中的位置时，(例如：color、background-color、visibility 等)，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘

### 性能影响

回流比重绘的代价要更高

现代浏览器会对频繁的回流或重绘操作进行优化：浏览器会维护一个队列,把所有引起回流和重绘的操作放入队列中,如果队列中的任务数量或者时间间隔达到一个阈值的,浏览器就会将队列清空,进行一次批处理,这样可以把多次回流和重绘变成一次。

### 如何避免

css

避免使用table布局

避免设置多层内联样式

js

避免频繁操作样式

避免频繁操作DOM


[参考文章](https://juejin.im/post/6844904160329285639)

## TCP 三次握手

客户端发起连接请求=》服务器确认连接请求=》客户端确认收到确认连接请求=》服务器等待接收请求、客户端发送请求


## Event Loop

js 是 单线程的， 有了Event Loop 的加持， JS 才能非阻塞地运行。


同步任务指的是：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
异步任务指的是：不进入主线程，而是进入任务队列，通过Event Loop 机制等待合适的时间调用


流程图如下：

![event-loop](https://tang-yue.github.io/interview/promise/event-loop.jpg)


总结：

先执行宏任务，后执行微任务，同步任务立即执行，异步任务将回调函数放入Event Queue等待下一轮事件循环


具体流程：

1、执行全局Script 代码，这些代码中有同步语句或异步语句，遇到同步语句直接执行，异步语句放入宏任务或微任务的队列。

2、全局 Script 代码执行完毕后，调用栈 Stack 会清空

3、从微任务中取出位于队首的回调任务，放入调用栈Stack 中执行，执行完成后，微任务队列长度减一

4、继续取出位于队首的任务，放入调用栈 Stack 中执行，以此类推，直到把微任务队列中的所有任务都执行完毕，注意，如果在执行微任务过程中，又产生了新的微任务，那么会加入到微任务队列的尾部，也会在这个周期被执行

5、当微任务队列中所有任务都执行完毕后，此时微任务队列为空，调用栈Stack 也会为空

6、取出 宏任务中的队首的任务放入 Stack 中执行

7、执行完毕后，调用栈 Stack 为空

8、重复第3～7个步骤

9、重复3～7 步骤


[参考文章](https://zhuanlan.zhihu.com/p/165149415)


## 浏览器安全

### XSS攻击

#### 什么是XSS攻击

  XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。

#### 危害

  1、窃取 Cookie 信息

  2、监听用户行为

  3、修改DOM

  4、在页面内生成浮窗广告

#### 阻止 XSS 攻击的策略

1、服务器对输入脚本进行过滤或转码
2、充分利用 CSP
  + 限制加载其他域下的资源文件
  + 禁止向第三方域提交数据
  + 禁止执行内联脚本和未授权的脚本

3、使用 HttpOnly 属性

用 HttpOnly 标记的Cookie 只能使用在 HTTP 请求过程中，所以无法通过 Javascript 来读取这段Cookie。

4、添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，增大XSS攻击的难度

为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。

### CSRF攻击

#### 什么是CSRF攻击

CSRF 攻击，又称为 “跨站请求伪造” 就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。

#### 三种攻击方式

1、自动发起Get请求

2、自动发起 POST 请求

3、引诱用户点击链接

比如用户填写

#### 如何防止 CSRF 攻击

发起CSRF攻击的三个必要条件

1、第一个，目标站点一定要有CSRF漏洞

2、第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态

3、第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛

#### 要让服务器避免遭受到CSRF攻击，有哪些途径

1、利用好 Cookie 的 SameSite 属性   即，是从第三方站点发起的请求，需要浏览器禁止发送某些关键Cookie数据到服务器，如果是同一个站点发起的请求，需要保证
Cookie 数据正常发送

2、验证请求的来源站点

如果是第三方站点，服务器禁止来自第三方站点的请求，优先判断 Origin (只包含了域名信息)，如果请求头中没有包含Origin 属性，再根据实际情况判断是否使用Referer 值

3、CSRF Token

在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token  其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。
在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该Token是否合法。


[浏览器工作原理与实践](https://time.geekbang.org/column/intro/216)


## 什么是同源策略

协议、域名 和端口都相同，称两个 URL 同源

### 如何解决跨域问题

1、JSONP 

只是请求了一个js文件并且执行了，而且这种跨域方法只能进行GET请求。

web 页面上调用js文件不受浏览器同源策略的影响，所以通过Script 便签可以进行跨域的请求：

(1) 首先前端先设置好回调函数，并将其作为url的参数。
(2) 服务端接受到请求后，通过该参数获得回调函数名，并将数据放在参数中将其返回。
(3) 收到结果后因为是script 标签，所以浏览器会当做是脚本进行运行，从而达到跨域获取数据的目的。

2、服务端代理

3、反向代理

4、window.name

5、location.hash

6、document.domain

## 4、Cookie, LocalStorage 与 SessionStorage

### 三者异同

| 特性         | Cookie     | localStorage  | sessionStorage      | 
| ----------- |:---------------:| -----------:| ----------------: |  
| 数据的生命周期 |  一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效     | 除非被清除，否则永久保存 |  仅在当前会话下有效，关闭页面或浏览器后被清除 | 
| 存放数据大小   |   4k 左右      |     5MB        
| 与服务器端通信 |   每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题    |  仅在客户端（即浏览器）中保存，不参与和服务器的通信     
| 易用性        | 需要程序员自己封装，原生的Cookie 接口不友好                        |  原生接口可以接受，亦可再次封装来对Object和Array 有更好的支持     

### 应用场景

cookie 一般存储 token 信息，不要放太多，因为每个http 请求都会带着Cookie的信息
localStorage   能存储很多信息
sessionStorage 把表单页面拆分成多个子页面，然后按步骤引导用户填写

### 安全性考虑

任何数据都不能放在以上三种中，需要时刻注意是否有代码存在xss注入的风险。
因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有xss的风险，它们就能对你的localStorage 肆意妄为。


## 浏览器缓存

### 浏览器缓存机制

1. 浏览器在加载资源时，先根据这个资源的一些http header 判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。
比如： 某个css 文件，如果浏览器在加载它所在的网页时，这个css 文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个 css，连请求都不会发送到网页所在的服务器；

2. 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些 http header 验证这个资源是否命中协商缓存，如果协商缓存命中，服务器
会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；

3. 强缓存和协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。

4. 当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。


### 强缓存

`Cache-Control: max-age=315360000` 这是一个相对时间，在配置缓存的时候，以秒为单位，根据它第一次的请求时间和Cache-Control 设定的有效期，计算出一个资源过期时间。

`Expires`和`Cache-Control`同时存在时，Cache-Control 优先级高于Expires.

### 协商缓存

+ 【Last-Modified, If-Modified-Since】 这对 Header 控制缓存

  - 1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在response的header 加上 Last-Modified，表示这个资源在服务器上的最后修改时间。

  - 2、浏览器再次跟服务器请求这个资源时，在request 的header 上加上 If-Modified-Since的 header， 这个就是header的值，就是上一次请求时返回的Last-Modified的值。

  - 3、服务器再次收到资源请求时，根据浏览器传过来的 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化。如果没有变化则返回 304 Not Modified，但不会返回资源内容，如果有变化，就正常返回资源内容。

  - 4、浏览器收到304的响应后，就会从缓存中加载资源。

  - 5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的 Last-Modified 值。

+ 【ETag、If-None-Match】 这对 header

    相同的原理


Etag 和 Last-Modified 相似，但是 ETag 相对 Last-Modified 也有其优势，可以更加准确的判断文件内容是否被修改。（因为会存在服务器上资源有变化，但是修改时间却没有变化的情况）


流程图如下：


![browser-cache](https://tang-yue.github.io/interview/browser-works/browser-cache.png)

[参考文章](https://juejin.im/post/6844903672556552205)



