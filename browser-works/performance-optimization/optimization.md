## 性能优化

优化方向
 + HTTP 请求
 + JS 加载

### 请求优化

#### 减少HTTP请求

#### 使用HTTP2

优点：

1. 解析速度快

> 服务器解析HTTP1.1的请求时，必须不断地读入字节，直到遇到分隔符CRLF为止，而解析HTTP2的请求就不用这么麻烦，因为HTTP2是基于帧的协议，每个帧都有表示帧长度的长段。

2. 多路复用

> HTTP1.1 如果要同时发起多个请求，就得建立多个TCP连接，因为一个TCP连接同时只能处理一个HTTP1.1的请求。在HTTP2上，多个请求可以共用一个TCP连接，这称为多路复用。
> 同一个请求和响应用一个流来表示，并有唯一的流ID来标识。多个请求和响应在TCP连接中可以乱序发送，到达目的地后再通过流ID重新组建。

3. 首部压缩

> 有时候两个请求，请求的头部信息有很多数据都是重复的，如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。
> HTTP2 在客户端和服务端使用“首部表”来跟踪和存储之前发送的键 - 值对，对于相同的数据，不再通过每次请求和响应发送。

4. 优先级

> HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。

5. 流量控制

> 由于一个TCP连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行进行精确控制。

6. 服务器推送

> HTTP2 新增的一个强大的新功能，就是服务器可以多一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。

#### 静态资源使用CDN

#### 善用缓存，不重复加载相同的资源

#### 图片优化

1. 图片延迟加载：在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。
2. 响应式图片：响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。
3. 调整图片大小：有一个很大的图，用缩略图的方式展示给用户，并且当用户鼠标悬停在上面时才展示全图。
4. 降低图片质量
5. 尽可能用CSS3效果代替图片
6. 使用字体图标iconfont代替图片图标

#### 资源压缩

### 加载优化

#### 将CSS放在文件头部，JavaScript文件放在底部

#### 合理配置webpack，node

1. 配置相关压缩插件
2. 按需加载
3. 提取第三方库
4. 删除死代码

#### 减少重绘回流

+ 用JavaScript修改样式时，最好不要直接写样式，而是替换class来改变样式。
+ 如果要对DOM元素执行一系列操作，可以将DOM元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或
文档碎片（DocumentFragement），都能很好的实现这个方案。

#### 使用 Web Workers

Web Worker 使用其他工作线程从而独立于主线程之外，它可以执行任务而不干扰用户界面。一个worker可以将消息发送到创建它的JavaScript代码，通过将消息发送
到该代码指定的事件处理程序。Web Worker 适用于那些处理纯数据，或者与浏览器UI无关的长时间运行脚本。可以避免渲染线程阻塞，从而达到性能优化。

#### 降低CSS选择器的复杂性

1. 选择器越短越好
2. 尽量使用高优先级的选择器，例如 ID 和类选择器
3. 避免使用通配符*

#### js代码优化

1. `if else` 用 `switch` 替换，或者用查找表

### 体验优化

#### 骨架屏

#### 服务端渲染

#### 动画

1. 使用`requestAnimationFrame`来实现视觉变化
2. 使用`transform 和 opacity`属性更改来实现动画

#### 虚拟滚动

页面进行滚动的时候，也会触发浏览器的重排，如果此时前端

参考：[https://mp.weixin.qq.com/s/IIlJBGmUSImFZ_8K6vVBGw]

[参考文章](https://github.com/i-want-offer/FE-Essay/blob/master/docs/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.md)